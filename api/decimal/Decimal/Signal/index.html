<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Signal (decimal.Decimal.Signal)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">decimal</a> &#x00BB; <a href="../index.html">Decimal</a> &#x00BB; Signal</nav><header class="odoc-preamble"><h1>Module <code><span>Decimal.Signal</span></code></h1><p>Signals are used to control the behaviour of the decimal functions under exceptional conditions.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-id" class="anchored"><a href="#type-id" class="anchor"></a><code><span><span class="keyword">type</span> id</span></code></div><div class="spec-doc"><p>Unique identifier of a signal.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-array" class="anchored"><a href="#type-array" class="anchor"></a><code><span><span class="keyword">type</span> array</span></code></div><div class="spec-doc"><p>Contains a set of signals.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-array">array</a></span></code></div><div class="spec-doc"><p><code>make ()</code> a new set of signals. All the signals are unset initially.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-array">array</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>get array id</code> is the set/unset state of the signal <code>id</code> in <code>array</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-array">array</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set array id bool</code> sets the state of the signal <code>id</code> in <code>array</code> to <code>bool</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string id</code> is <code>id</code>'s name.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-array">array</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp f array</code> pretty-prints the signal array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clamped" class="anchored"><a href="#val-clamped" class="anchor"></a><code><span><span class="keyword">val</span> clamped : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Exponent of a 0 changed to fit bounds.</p><p>This occurs and signals clamped if the exponent of a result has been altered in order to fit the constraints of a specific concrete representation. This may occur when the exponent of a zero result would be outside the bounds of a representation, or when a large normal number would have an encoded exponent that cannot be represented. In this latter case, the exponent is reduced to fit and the corresponding number of zero digits are appended to the coefficient (&quot;fold-down&quot;).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-invalid_operation" class="anchored"><a href="#val-invalid_operation" class="anchor"></a><code><span><span class="keyword">val</span> invalid_operation : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>An invalid operation was performed.</p><p>Various bad things cause this:</p><ul><li>-∞ + ∞</li><li>0 × ±∞</li><li>±∞ / ±∞</li><li>x mod 0</li><li>±∞ mod x</li><li>sqrt ~-x, x &gt; 0</li><li>0 ** 0</li><li>x ** (non-integer)</li><li>x ** ±∞</li><li>An operand is invalid</li></ul><p>The result of the operation after these is a <code>NaN</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-conversion_syntax" class="anchored"><a href="#val-conversion_syntax" class="anchor"></a><code><span><span class="keyword">val</span> conversion_syntax : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Trying to convert badly formed string.</p><p>This occurs and signals invalid-operation if a string is being converted to a number and it does not conform to the numeric string syntax. The result is <code>NaN</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-div_by_zero" class="anchored"><a href="#val-div_by_zero" class="anchor"></a><code><span><span class="keyword">val</span> div_by_zero : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Division by 0.</p><p>This occurs and signals division-by-zero if division of a finite number by zero was attempted (during a divide-integer or divide operation, or a power operation with negative right-hand operand), and the dividend was not zero.</p><p>The result of the operation is <code>(sign)Inf</code>, where <code>(sign)</code> is the exclusive or of the signs of the operands for divide, or is 1 for an odd power of -0, for power.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-div_impossible" class="anchored"><a href="#val-div_impossible" class="anchor"></a><code><span><span class="keyword">val</span> div_impossible : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Cannot perform the division adequately.</p><p>This occurs and signals invalid-operation if the integer result of a divide-integer or remainder operation had too many digits (would be longer than precision). The result is <code>NaN</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-div_undefined" class="anchored"><a href="#val-div_undefined" class="anchor"></a><code><span><span class="keyword">val</span> div_undefined : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Undefined result of division.</p><p>This occurs and signals invalid-operation if division by zero was attempted (during a divide-integer, divide, or remainder operation), and the dividend is also zero. The result is <code>NaN</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inexact" class="anchored"><a href="#val-inexact" class="anchor"></a><code><span><span class="keyword">val</span> inexact : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Had to round, losing information.</p><p>This occurs and signals inexact whenever the result of an operation is not exact (that is, it needed to be rounded and any discarded digits were non- zero), or if an overflow or underflow condition occurs. The result in all cases is unchanged. The inexact signal may be tested (or trapped) to determine if a given operation (or sequence of operations) was inexact.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rounded" class="anchored"><a href="#val-rounded" class="anchor"></a><code><span><span class="keyword">val</span> rounded : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Number got rounded (not necessarily changed during rounding).</p><p>This occurs and signals rounded whenever the result of an operation is rounded (that is, some zero or non-zero digits were discarded from the coefficient), or if an overflow or underflow condition occurs. The result in all cases is unchanged.</p><p>The rounded signal may be tested (or trapped) to determine if a given operation (or sequence of operations) caused a loss of precision.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subnormal" class="anchored"><a href="#val-subnormal" class="anchor"></a><code><span><span class="keyword">val</span> subnormal : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Exponent &lt; Emin before rounding.</p><p>This occurs and signals subnormal whenever the result of a conversion or operation is subnormal (that is, its adjusted exponent is less than Emin, before any rounding). The result in all cases is unchanged. The subnormal signal may be tested (or trapped) to determine if a given or operation (or sequence of operations) yielded a subnormal result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-overflow" class="anchored"><a href="#val-overflow" class="anchor"></a><code><span><span class="keyword">val</span> overflow : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Numerical overflow.</p><p>This occurs and signals overflow if the adjusted exponent of a result (from a conversion or from an operation that is not an attempt to divide by zero), after rounding, would be greater than the largest value that can be handled by the implementation (the value Emax).</p><p>The result depends on the rounding mode:</p><p>For round-half-up and round-half-even (and for round-half-down and round- up, if implemented), the result of the operation is <code>sign,inf</code>, where sign is the sign of the intermediate result. For round-down, the result is the largest finite number that can be represented in the current precision, with the sign of the intermediate result. For round-ceiling, the result is the same as for round-down if the sign of the intermediate result is <code>-</code>, or is <code>Inf</code> otherwise. For round-floor, the result is the same as for round-down if the sign of the intermediate result is <code>+</code>, or is <code>-Inf</code> otherwise. In all cases, Inexact and Rounded will also be raised.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-underflow" class="anchored"><a href="#val-underflow" class="anchor"></a><code><span><span class="keyword">val</span> underflow : <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p>Numerical underflow with result rounded to 0.</p><p>This occurs and signals underflow if a result is inexact and the adjusted exponent of the result would be smaller (more negative) than the smallest value that can be handled by the implementation (the value Emin). That is, the result is both inexact and subnormal.</p><p>The result after an underflow will be a subnormal number rounded, if necessary, so that its exponent is not less than Etiny. This may result in 0 with the sign of the intermediate result and an exponent of Etiny.</p><p>In all cases, Inexact, Rounded, and Subnormal will also be raised.</p></div></div></div></body></html>