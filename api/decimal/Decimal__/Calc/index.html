<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Calc (decimal.Decimal__.Calc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">decimal</a> &#x00BB; <a href="../index.html">Decimal__</a> &#x00BB; Calc</nav><h1>Module <code>Decimal__.Calc</code></h1></header><aside><p>Integer arithmetic functions used by <code>ln</code>, <code>log10</code>, <code>exp</code>, and <code>pow</code>.</p></aside><dl><dt class="spec value" id="val-z2"><a href="#val-z2" class="anchor"></a><code><span class="keyword">val</span> z2 : Z.t</code></dt><dt class="spec value" id="val-z10"><a href="#val-z10" class="anchor"></a><code><span class="keyword">val</span> z10 : Z.t</code></dt><dt class="spec value" id="val-z100"><a href="#val-z100" class="anchor"></a><code><span class="keyword">val</span> z100 : Z.t</code></dt><dt class="spec value" id="val-zeros"><a href="#val-zeros" class="anchor"></a><code><span class="keyword">val</span> zeros : Str.regexp</code></dt><dt class="spec value" id="val-unreliable"><a href="#val-unreliable" class="anchor"></a><code><span class="keyword">val</span> unreliable : Str.regexp</code></dt><dd><p>Unreliable digits at the end of the <code>log10_digits</code> calculation</p></dd></dl><dl><dt class="spec value" id="val-decimal_lshift_exact"><a href="#val-decimal_lshift_exact" class="anchor"></a><code><span class="keyword">val</span> decimal_lshift_exact : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Z.t option</span></code></dt><dd><p><code>decimal_lshift_exact n e</code> is <code>Some (n * 10 ** e)</code> if it's an integer, else <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-sqrt_nearest"><a href="#val-sqrt_nearest" class="anchor"></a><code><span class="keyword">val</span> sqrt_nearest : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dt class="spec value" id="val-sqrt_nearest"><a href="#val-sqrt_nearest" class="anchor"></a><code><span class="keyword">val</span> sqrt_nearest : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>sqrt_nearest n a</code> is the closest integer to the square root of the positive integer <code>n</code>. <code>a</code> is an initial approximation of the square root. Any positive integer will do for <code>a</code>, but the closer <code>a</code> is to the square root of <code>n</code> the faster convergence will be.</p></dd></dl><dl><dt class="spec value" id="val-rshift_nearest"><a href="#val-rshift_nearest" class="anchor"></a><code><span class="keyword">val</span> rshift_nearest : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>rshift_nearest x shift</code> is the closest integer to <code>x / 2**shift</code>, where <code>shift</code> is non-negative. Uses round-to-even in case of a tie.</p></dd></dl><dl><dt class="spec value" id="val-div_nearest"><a href="#val-div_nearest" class="anchor"></a><code><span class="keyword">val</span> div_nearest : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dt class="spec value" id="val-ilog"><a href="#val-ilog" class="anchor"></a><code><span class="keyword">val</span> ilog : <span>?&#8288;l:int</span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>ilog ?l x m</code> is the integer approximation to <code>m * log (x / m)</code>, with absolute error boundable in terms only of <code>x / m</code>.</p><p>Given positive integers <code>x</code> and <code>m</code>, return an integer approximation to <code>m * log (x / m)</code>. For <code>l = 8</code> and <code>0.1 &lt;= x / m &lt;= 10</code> the difference between the approximation and the exact result is at most 22. For <code>l = 8</code> and <code>1.0 &lt;= x / m &lt;= 10.0</code> the difference is at most 15. In both cases these are upper bounds on the error; it will usually be much smaller.</p></dd></dl><dl><dt class="spec value" id="val-log10_digits"><a href="#val-log10_digits" class="anchor"></a><code><span class="keyword">val</span> log10_digits : <span>string Stdlib.ref</span></code></dt><dt class="spec value" id="val-log10_digits"><a href="#val-log10_digits" class="anchor"></a><code><span class="keyword">val</span> log10_digits : int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>log10_digits p</code> is <code>(floor 10**p) * log 10</code>, given <code>p &gt;= 0</code>. For example, <code>log10_digits 3</code> is 2302.</p></dd></dl><dl><dt class="spec value" id="val-dlog10"><a href="#val-dlog10" class="anchor"></a><code><span class="keyword">val</span> dlog10 : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>dlog10 c e p</code> is an integer approximation of <code>10**p * log10 (c * 10**e)</code>, with an absolute error of at most 1. Assumes that:</p><ul><li><code>c &gt; 0</code></li><li><code>p &gt;= 0</code></li><li><code>c * 10**e</code> is not exactly 1</li></ul></dd></dl><dl><dt class="spec value" id="val-dlog"><a href="#val-dlog" class="anchor"></a><code><span class="keyword">val</span> dlog : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>dlog c e p</code> is an integer approximation of <code>10**p * log (c * 10 * e)</code>, with an absolute error of at most 1. Assumes that <code>c * 10 * e</code> is not exactly 1.</p></dd></dl><dl><dt class="spec value" id="val-iexp"><a href="#val-iexp" class="anchor"></a><code><span class="keyword">val</span> iexp : <span>?&#8288;l:int</span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>iexp ?l x m</code> is an integer approximation of <code>m * exp (x / m)</code>, given <code>m &gt; 0</code> and such that <code>x / m</code> is small in absolute value. For <code>0 &lt;= x / m &lt;= 2.4</code>, the absolute error in the result is bounded by 60 (and is usually much smaller).</p></dd></dl><dl><dt class="spec value" id="val-dexp"><a href="#val-dexp" class="anchor"></a><code><span class="keyword">val</span> dexp : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t * int</code></dt><dd><p><code>dexp c e p</code> is an approximation to <code>exp (c * 10**e)</code>, with <code>p</code> decimal places of precision.</p><p>Returns integers <code>d, f</code> such that:</p><ul><li><code>10**(p - 1) &lt;= d &lt;= 10**p</code>, and</li><li><code>(d - 1) * 10**f &lt; exp (c * 10**e) &lt; (d + 1) * 10**f</code></li></ul><p>In other words, <code>d * 10**f</code> is an approximation to <code>exp (c * 10**e)</code> with <code>p</code> digits of precision, and with an error in <code>d</code> of at most <code>1</code>. This is almost, but not quite, the same as the error being &lt; 1ulp: when <code>d = 10**(p - 1)</code> the error could be up to 10 ulp.</p></dd></dl><dl><dt class="spec value" id="val-dpower"><a href="#val-dpower" class="anchor"></a><code><span class="keyword">val</span> dpower : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t * int</code></dt><dd><p><code>dpower xc xe yc ye p</code> is <code>x ** y</code>, given integers <code>xc</code>, <code>xe</code>, <code>yc</code>, and <code>ye</code> representing decimals <code>x = xc * 10**xe</code> and <code>y = yc * 10**ye</code>. Returns a pair of integers <code>c, e</code> such that:</p><ul><li><code>10**(p - 1) &lt;= c &lt;= 10**p</code>, and</li><li><code>(c - 1) * 10**e &lt; x**y &lt; (c + 1) * 10**e</code></li></ul><p>In other words, <code>c * 10**e</code> is an approximation to <code>x**y</code> with <code>p</code> digits of precision, and with an error in <code>c</code> of at most <code>1</code>. This almost, but not quite, the same as the error being &lt; 1ulp: when <code>c = 10**(p - 1)</code> we can only guarantee error &lt; 10ulp.</p><p>We assume that: <code>x</code> is positive and not equal to <code>1</code>, and <code>y</code> is nonzero.</p></dd></dl><dl><dt class="spec value" id="val-log10_lb"><a href="#val-log10_lb" class="anchor"></a><code><span class="keyword">val</span> log10_lb : <span>?&#8288;correction:<span><span>(char * int)</span> list</span></span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> int</code></dt><dd><p><code>log10_lb ?correction c</code> is a lower bound for <code>100 * log10 c</code> for a positive integer <code>c</code>.</p></dd></dl></div></body></html>