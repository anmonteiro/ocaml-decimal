<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Calc (decimal.Decimal__.Calc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">decimal</a> &#x00BB; <a href="../index.html">Decimal__</a> &#x00BB; Calc</nav><h1>Module <code>Decimal__.Calc</code></h1></header><aside><p>Integer arithmetic functions used by <code>ln</code>, <code>log10</code>, <code>exp</code>, and <code>pow</code>.</p></aside><dl><dt class="spec value" id="val-z2"><a href="#val-z2" class="anchor"></a><code><span class="keyword">val</span> z2 : Z.t</code></dt><dt class="spec value" id="val-z10"><a href="#val-z10" class="anchor"></a><code><span class="keyword">val</span> z10 : Z.t</code></dt><dt class="spec value" id="val-z100"><a href="#val-z100" class="anchor"></a><code><span class="keyword">val</span> z100 : Z.t</code></dt><dt class="spec value" id="val-zeros"><a href="#val-zeros" class="anchor"></a><code><span class="keyword">val</span> zeros : Str.regexp</code></dt><dt class="spec value" id="val-unreliable"><a href="#val-unreliable" class="anchor"></a><code><span class="keyword">val</span> unreliable : Str.regexp</code></dt><dd><p>Unreliable digits at the end of the <code>log10_digits</code> calculation</p></dd></dl><dl><dt class="spec value" id="val-decimal_lshift_exact"><a href="#val-decimal_lshift_exact" class="anchor"></a><code><span class="keyword">val</span> decimal_lshift_exact : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Z.t option</span></code></dt><dd><p><code>decimal_lshift_exact n e</code> is <code>Some (n * 10 ** e)</code> if it's an integer, else <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-sqrt_nearest"><a href="#val-sqrt_nearest" class="anchor"></a><code><span class="keyword">val</span> sqrt_nearest : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dt class="spec value" id="val-sqrt_nearest"><a href="#val-sqrt_nearest" class="anchor"></a><code><span class="keyword">val</span> sqrt_nearest : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>sqrt_nearest n a</code> is the closest integer to the square root of the positive integer <code>n</code>. <code>a</code> is an initial approximation of the square root. Any positive integer will do for <code>a</code>, but the closer <code>a</code> is to the square root of <code>n</code> the faster convergence will be.</p></dd></dl><dl><dt class="spec value" id="val-rshift_nearest"><a href="#val-rshift_nearest" class="anchor"></a><code><span class="keyword">val</span> rshift_nearest : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>rshift_nearest x shift</code> is the closest integer to <code>x / 2**shift</code>, where <code>shift</code> is non-negative. Uses round-to-even in case of a tie.</p></dd></dl><dl><dt class="spec value" id="val-div_nearest"><a href="#val-div_nearest" class="anchor"></a><code><span class="keyword">val</span> div_nearest : Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dt class="spec value" id="val-ilog"><a href="#val-ilog" class="anchor"></a><code><span class="keyword">val</span> ilog : <span>?&#8288;l:int</span> <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>ilog ?l x m</code> is the integer approximation to <code>m * log (x / m)</code>, with absolute error boundable in terms only of <code>x / m</code>.</p><p>Given positive integers <code>x</code> and <code>m</code>, return an integer approximation to <code>m * log (x / m)</code>. For <code>l = 8</code> and <code>0.1 &lt;= x / m &lt;= 10</code> the difference between the approximation and the exact result is at most 22. For <code>l = 8</code> and <code>1.0 &lt;= x / m &lt;= 10.0</code> the difference is at most 15. In both cases these are upper bounds on the error; it will usually be much smaller.</p></dd></dl><dl><dt class="spec value" id="val-log10_digits"><a href="#val-log10_digits" class="anchor"></a><code><span class="keyword">val</span> log10_digits : <span>string Stdlib.ref</span></code></dt><dt class="spec value" id="val-log10_digits"><a href="#val-log10_digits" class="anchor"></a><code><span class="keyword">val</span> log10_digits : int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>log10_digits p</code> is <code>(floor 10**p) * log 10</code>, given <code>p &gt;= 0</code>. For example, <code>log10_digits 3</code> is 2302.</p></dd></dl><dl><dt class="spec value" id="val-dlog10"><a href="#val-dlog10" class="anchor"></a><code><span class="keyword">val</span> dlog10 : Z.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Z.t</code></dt><dd><p><code>dlog10 c e p</code> is an integer approximation of <code>10**p * log10 (c * 10**e)</code>, with an absolute error of at most 1. Assumes that:</p><ul><li><code>c &gt; 0</code></li><li><code>p &gt;= 0</code></li><li><code>c * 10**e</code> is not exactly 1</li></ul></dd></dl></div></body></html>